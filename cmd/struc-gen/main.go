package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"runtime/debug"

	"github.com/dave/jennifer/jen"
	"github.com/m29h/struc-gen/cmd/struc-gen/internal/generator"
	"golang.org/x/tools/go/packages"
)

func main() {

	var sourceFilePackage = flag.String("file", os.Getenv("GOFILE"), "source file name containing struct definition to generate")
	var version = flag.Bool("version", false, "show version information")
	flag.Parse()
	if *version {
		bi, ok := debug.ReadBuildInfo()
		if !ok {
			log.Printf("Failed to read build info")
			return
		}

		fmt.Printf("struc-gen %s\n", bi.Main.Version)
		return
	}

	if *sourceFilePackage == "" {
		flag.PrintDefaults()
		return
	}
	fmt.Printf("file=%s\n", *sourceFilePackage)
	// Inspect package and use type checker to infer imported types

	pkg := loadPackage(*sourceFilePackage)
	fmt.Printf("%s %s\n", pkg.CompiledGoFiles[0], os.Getenv("GOPACKAGE"))

	// Lookup the given source type name in the package declarations
	parsetypes := make(map[string]*types.Struct)
	for _, sourceTypeName := range pkg.Types.Scope().Names() {

		obj := pkg.Types.Scope().Lookup(sourceTypeName)

		if obj == nil {
			failErr(fmt.Errorf("%s not found in declared types of %s",
				sourceTypeName, pkg))
		}

		// We check if it is a declared type
		if _, ok := obj.(*types.TypeName); !ok {
			continue
			//failErr(fmt.Errorf("%v is not a named type", obj))
		}
		// We expect the underlying type to be a struct
		structType, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			continue
		}
		parsetypes[sourceTypeName] = structType

	}
	if len(parsetypes) == 0 {
		fmt.Printf("No struct definition(s) found in source file. Nothing to do \n")
		return
	}
	err := generate(pkg, parsetypes)
	if err != nil {
		failErr(err)
	}
}

func generate(pkg *packages.Package, t map[string]*types.Struct) error {

	// Start a new file in this package
	f := jen.NewFile(pkg.Name)

	// Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	// Collect Function block serializing whole struct
	for sourceTypeName, structType := range t {
		fmt.Printf("->%s\n", sourceTypeName)
		mb := generator.NewMethodBuilder(sourceTypeName, structType)
		f.Add(mb.MakeMethods())
	}

	// Build the target file name
	goFile := pkg.CompiledGoFiles[0]
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_gen.go"

	// Write generated file
	return f.Save(targetFilename)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedDeps | packages.NeedTypesInfo | packages.NeedTypes | packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		failErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func failErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
